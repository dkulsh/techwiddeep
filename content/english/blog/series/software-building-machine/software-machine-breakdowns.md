---
title: "Software Machine Breakdowns"
meta_title: "Software Machine Breakdowns - Common Problems in Software Development Organizations"
description: "Explore the common breakdowns and challenges that affect software development machines. Learn about poor parts, friction, malleability issues, and the subjective-objective paradox."
date: 2021-08-23T00:00:00Z
image: "/images/software-building-machine/breakdowns-cover.jpg"
categories: ["Software Development", "Business Strategy"]
author: "Deep Kulshreshtha"
tags: ["software-engineering", "business-analysis", "team-management"]
draft: false
weight: 2
toc: true
---

What are the common breakdowns in a software-making machine?

In the previous blog, we looked at how a software-making machine works, meaning how a software company functions. ([Software Producing Machine](/blog/series/software-building-machine/software-producing-machine/))

Continuing the discussion, we look at the common problems at a software company. In other words, common problems within a software-making machine.

![Image](/images/software-building-machine/machine-breakdown-concept.jpg)

The first spot goes to the most obvious one.

#### Poor Parts

A machine can have poor parts. In our context, these will be:

- Clients

They might not know *how* to give requirements. Or worse, might not know *what they want*. Believe it or not, it's more common than you'd imagine.

- Analysts

Might be *unable to translate* business requirements to tech ones or vice versa.

- Techies

*Do not know technology* or not at the required skill level.

- Managers

Might not know *how to manage*, delegate, prioritize, coordinate, etc.

- QA Team

Might not know *how to test* functionality.

![Image](/images/software-building-machine/poor-parts-diagram.jpg)

Or, all the above. In which case, the faulty part is...

- *The Leader (Director/VP)*

Their job is to tune and replace the machine parts, such as techies and managers. But they might not have the skills to recognize and fix faulty parts. And again, it's more common than you'd think.

Out-of-tune or faulty parts is a common problem in software machines.

To address these issues, let's examine another common challenge.

#### Friction

While energy is neither created nor destroyed, it is gained and lost.

When two parts of a machine do not coordinate with each other, they lose energy. Within a software development machine, the loss looks like...

- Throw-away code

- Duplicated efforts

- Missed requirements

- Poorly scheduled dependencies

![Image](/images/software-building-machine/friction-concept.jpg)

*Friction loses effort*. To me, this point is easily understood by most people. For this reason, I will not elaborate on it.

Onto the next issue type.

#### Malleable

Software is malleable (able to change shape without breaking).

![Image](/images/software-building-machine/malleability-concept.jpg)

On one hand, malleability is a strength for the software itself. On the other, this is a challenge for the software-producing machine.

Let's elaborate:

1. Most software companies have a different name for their development environments (dev, test, and production).

   - One called it E1, E2, E3 environments.

   - Another called them Alpha, Beta, and Gamma.

   - Yet another called it dev, integration, certification, and production environment.

This means each employee joining the company will have to first understand the conventions and only then start being productive.

Also, most companies have poor onboarding practices.

Combining both points: Poor onboarding practices plus different names equals engineers joining teams and architecture they do not understand.

A great employee joins a team. Do they understand the local nomenclature? In most cases, the answer is no.

*Result: Most employees struggle to be productive*. I did!

On one hand, the ability to custom-name environments is an advantage. On the other, it hampers scalability across the industry.

Lack of standard nomenclature is a decelerating factor in the software development machine.

- A product-based company is very different from a service-based company in:

  - Development practices

  - The number of employees

  - Quality of work

  - Hierarchy structure

  - Dressing standards, etc.

Similarly, two product-based software companies are not the same.

While such malleability is welcome, it creates a situation where each part (employee) needs to first acclimatize to its environment and only then become productive.

![Image](/images/software-building-machine/malleability-challenge.jpg)

The malleability of software creates an easily changeable environment. Such an environment needs the machine to spend time adjusting to its environment and, of course, producing code.

No surprise that ever-changing software machines are slow.

Building on these challenges, consider the inherent nature of inputs and outputs.

#### Subjective Input Objective Output

##### Heads Up! This idea will be tricky to understand. While so, it will also be a valuable insight into how a software machine works. Also, this section is why my blogs are worth reading.

##### Subjective Input

Let's look at the input to the software developing machine: requirements. We know that requirements are words, and words are subjective. By derivation, input to a software machine is subjective.

Even when well documented, words are easy to be "interpreted" per one's bias or convenience.

- Understanding a requirement differently... easy.

- Missing acceptance criteria... easy.

- Omitting scope... easy.

- Forgetting a schedule... easy.

Also, words, by their nature, are momentary. To prove that, let me ask you a question.

How many conversations do you remember from today, "word for word"?

Very few, you say! Exactly my point.

Capturing all the nuances of every requirement with all cases is a difficult job. As a writer, I can tell you that putting ideas into words is in itself a difficult task. Doing so at an organization's scale is a next-level task.

##### Objective Output

While the input of a software machine is subjective, the output is objective. This is because clients expect software to work in a certain manner.

Combining the two points, we have a machine with a subjective input and objective output. Inherently at odds, these create perfect conditions for messing up development work.

![Image](/images/software-building-machine/subjective-objective-paradox.png)

The contrary nature of input/output creates issues like...

- "But this is what we meant..."

- "We assumed such and such..."

- "We'd like to clarify whether this means that..."

Evolution designed humans for audio/visual cues, and not words. (I realize the irony with the length of my blog here.) Even so, words are the input to our software development machine. Meaning, humans face a disadvantage in using words to produce code, i.e., using subjective input to create an objective output.

Organizations aware of this paradox put quality checks into their requirements gathering process. The others find issues much later, with high repair costs.

This is another common reason for issues in software development machines.

##### Activity Time: Try and recall the first few lines of this blog. (Do not scroll back.)

##### Seriously, do it!

Most of us will be unable to do so. This goes to prove the momentary nature of words.

Do you see how easily requirements can be missed?

Moving on to the final challenge.

#### Nature of the Ware

The virtual nature of software makes it difficult to reach the root cause of software issues.

To understand this statement, help me answer these questions...

- How much does software weigh?

- Does it sound melodious or plain?

- What color would software have?

- Would it taste bland, bitter, or sour?

![Image](/images/software-building-machine/virtual-software-concept.jpg)

(For your sake) I hope you weren't able to answer any of the above questions. Obviously, the next question is:

- How would we evaluate software?

This question is the starting point of our discussion.

A wine, a dish, a piece of marble, a car, an egg, and other things exist in the real world. We also know that software exists in the virtual world (inside a computer).

![Image](/images/software-building-machine/virtual-world-concept.jpg)

None of the five human senses—touch, smell, see, taste, and hear—help us look inside a computer. So, we are put at an immediate disadvantage while evaluating software programs.

While most of us will agree with the above idea, few will "really" understand it. So, allow me an example.

##### A Virtual World

Seen the movie *Inception*, *Matrix*, or *Free Guy*?

The movies depict a virtual world with some rules. While a few rules were unchangeable, most were changeable. Also, these rules were created by an architect.

In the movie *The Matrix*, imagine a city where everyone owns a bus and not a car or bike. Let's imagine a typical morning:

- People driving buses to buy bread and milk.

- Kids going to school in their parents' buses.

- Adults going to their offices, each in their own bus.

Would a normal road infrastructure support such traffic? Hell no!

![Image](/images/software-building-machine/traffic-jam-analogy.jpg)

The result would be traffic jams and blockages. This is what happens within the software and is called a performance issue.

In our context, this is a poor quality output from the software development machine.

In the real world, people would quickly see the shortcomings of road infrastructure. Someone would object very soon. By comparison, hardly anyone would object to the design within a program.

And why?

*Because looking inside a virtual world requires skills, experience, time, and energy*. In other words, because it's difficult.

While the real world has bound rules and tangible results, the virtual one has very few rules. More importantly, a virtual end product.

The virtual nature of software makes it difficult to reach the root cause of software issues.

Expensive debugging is another common issue in the software-creating machine.

#### Wrap Up

We can look at a software company like any other machine, like a car. Once we do, we will realize that, like a car, a software company can...

- Have the best driver but the worst parts. And it won't run well.

- Have the best parts and worst drivers. Again, it won't run well.

And just like a Ferrari, high-quality software requires many things:

- Quality parts

- Good design

- Regular maintenance

- Great operators

- And more.

Only when all factors work together, the software machine delivers Ferrari code.

![Image](/images/software-building-machine/ferrari-code-concept.jpg)

*Thanks to Ray Dalio for helping me see a "Software development company" as a machine. (From his book Principles.)*

Write back if you have an opinion. Like what you read? Do like, comment, and share.

---

## Series Navigation

**Previous ←**: [Software Producing Machine](/blog/series/software-building-machine/software-producing-machine/)

**Series Progress**: Part 2 of 2 | [View All Posts](/blog/series/software-building-machine/)
